Arduino on breadboard with 32.768 KHz crystal

CKSEL[3:0] = 0010 (Use internal RC oscillator as the clock)
This should be set by the "Arduino on Breadboard" board model.

C_e = 2(12.5) - 6 = 19 pF external capacitors required when using crystal as timer oscillator
(Can try 22 or 15.)

Arduino as ISP -- need to use adafruit's fork and connect pin 9 to pin 9 to provide a clock signal

Slide detection: Just using this to detect movement out of the OFF position, the comparator
threshold may need to be adjusted if the stop size is adjusted significantly. 50 mV seems like a
reasonable starting point. Except that the bottom of the slide isn't really zero, at least on the
pot side that I fried. The other one actually looks OK. It will be nicer to have a larger "OFF"
area anyway so it's harder to turn it on by accident, so I will make that stop larger. And this
threshold needs to actually be something that registers as a stop so you can't end up in an "ON"
state that just drains the battery. You need to know it's on if it's using power. The circuit is a
voltage divider, so the threshold is a percentage of the input voltage. The first stop (where the
buzzer goes off) is currently at 3% of the total voltage, so that's what the voltage divider will
do. So this DEFINITELY needs to be adjusted if the stops are changed.

I tried to avoid possible bad states by having the software always be in "ringing" state when the
slider is below the first stop and just let the state of the power switch circuit override this. So,
if the power switch is in the "off" position, the timer is always actually powered down. However,
this doesn't work. It would make it possible for the motor, when moving the slider to stop zero, to
actually turn off the timer. In other words, when the timer reaches zero, it could just turn itself
off immediately and never ring. Bad idea! The big advantage of the current implementation (treating
OFF as a stop and only shutting down once that stop is reached) is that a human must actually move
the slider to that position before the timer will go off, which is the desired behavior.


How to fix it:
- Stops at fixed intervals, except OFF and ZERO, which should be further apart (wider). This means
  division to figure out which stop we're at instead of binary search
- Treat the value coming from the ADC as having some precision (e.g. +/- 2), only do something if
  it changes by more than the precision
- Each stop should have a "size" for the purpose of positioning the slider. Once the slider gets
  within that range once (currentStop == nextStop), don't move it any more unless it actually goes
  to a different stop (either from the stopwatch or because the user moved it)
- Be explicit about the mode we're in, possibly based on what interrupt woke us up
  - For the timer, just see if it's time to move to the next stop
  - For the ADC, just do the position handling (differently when currentStop == nextStop, as above)

Alarm:
- Getting the melody to work is a pain. The tone() libary seems to use Timer2, which we are already
  using. Timer1 would be better. Also, need to decide if we can sleep (and for how long) while the
  timer is going off. Don't want to misread a position.
- The buzzer just doesn't sound good. Going to try a speaker. It should actually be easier to play a
  sound that way using this library:
  https://github.com/TMRh20/AutoAnalogAudio/blob/master/examples/SimpleSine/SimpleSine.ino


TODO:
- Draw schematic
- Check timing accuracy
